<h1> 교착상태(DeadLock)과 기아상태(Starvation)의 개념과 발생 원인 </h1>

- 교착 상태란, 결코 일어나지 않을 사건(이벤트)에 대해 프로세스가 기다리고 있는 것
 
- 기아 상태란, 무기한 연기로 인해 아무리 기다려도 자신의 차례가 돌아오지 않는 것을 말함

- 다중 프로그래밍 시스템에서, 프로세스들이 한정된 시스템 자원 차지를 위해 경쟁할 떄 발생할 수 있음

- 교착 상태, 기아 상태는 프로세스가 작업을 수행하지 못하고, 무한히 대기한다는 공통점이 있음

<h2> 교착 상태 예시 </h2>

- 프로세스 A와 B는 스캐너, CD 레코더를 공유합니다.

- 프로세스 A는 스캐너를 할당받고, CD 레코더를 추가로 할당받습니다.

- 프로세스 B는 CD레코더를 할당받고, 스캐너를 추가로 할당받습니다.

- 위와 같은 경우, 서로가 사용중인 자원을 요청하게 되므로, 사이클이 발생하여 교착 상태에 빠질 수 있습니다.
- 이 외에도, 스풀링 시스템의 교착 상태, 네트워크에서 발생하는 교착 상태, 장치 할당 요구 시 발생하는 교착 상태가 있습니다.

<h2> 교착 상태가 시스템에 미치는 영향 </h2>

- 자원 요구가 뒤엉켜, 교착 상태에 빠진 프로세스들은 반납되지 않을 자원을 무한정 기다리게 됩니다.

- 이 경우, 작업을 더 이상 진행할 수 없게 되므로, 운영체제가 교착 상태를 해결해주어야 하빈다.

- 만약, 운영체제가 교착상태를 해결하지 못한다면, 사용자가 직접 프로그램을 종료하는 방법으로 해결해야 합니다.<hr>
  (프로그램을 강제 종료하여 교착 상태를 해겨할 경우, 데이터 손실 위험 존재)
  
<h2> 프로세스가 자원을 사용하는 순서 <h2>
  
  자원의 요청 및 해제는 시스템 호출로 수행합니다.
  
  - 요청 : 프로세스가 필요한 자원을 요청
    - 요청이 수락되면 자원을 할당받음
    - 요청이 즉시 수락되지 않으면 다른 프로세스가 해당 자원을 사용중 이므로, 할당 받을 떄까지 대기
  - 사용
    - 프로세스가 요청한 자원을 점유하여 사용
  - 해제
    - 프로세스가 자원 사용을 마친 이후에는 자원을 반납
  
 <h2> 교착상태 발생 조건</h2>
  
  교착 상태가 발생하려면 다음과 같은 4가지를 만족해야 한다.
  1. 상호 배제(mutual exclusion)
    - 1번에 1개의 프로세스만 해당 자원 사용 가능
  2. 점유와 대기(hold and wait)
    - 최소한 자원 1개를 차지하고, 다른 프로세스에 할당된 자원을 얻기 위해 대기 
  
  3. 비선점(no-preemption)
    - 자원이 선점될 수 없으며, 자원을 점유하고 있는 프로세스가 자원 사용을 마쳐야 해제 가능
  
  4. 순환 대기(circular wait)
    - 대기 프로세스 집합이 있을 때, 프로세스 a는 프로세스 b가 점유하고 있는 자원을, 프로세스 b는 프로세스 c가 점유하고 있는
      자원을, 프로세스 c는 프로세스 a가 점유하고 있는 자원을 대기( 점유-대기 사이클 형성)
  
  
  <h2> 교착 상태 예방(Deadlock Prevention) </h2>
  교착상태 필요 조건 4가지 중, 1개만 방지하여도 교착 상태를 예방할 수 있음
  
  - 점유와 대기(hold and wait) 조건 방지
  - 비선점(No-preemption) 조건 방지
  - 순환 대기(Circular wait) 조건 방지
  
  상호 배제(Mutual exclusion) 조건 방지는 제외한다.
  교착 상태 문제 자체가 한 순간에 프로세스를 1개만 사용할 수 있는 자원이기 때문이다.
  
  1. **점유와 대기(Hold and wait) 조건 방지**
  
  - **원리**
  
    - 프로세스가 자원을 점유한 채로 다른 자원을 기다리는 일을 없앤다.
  
  - 자원을 점유한 프로세스는 추가 자원을 요청할 수 없도록 한다.
  
  - **방법**
  
  - 각 프로세스는 필요한 모든 자원을 1번에 요청해야 한다.
  
  - 요청한 자원을 모두 할당받기 전까지는 작업 진행이 불가하다.
  
  - **변형 방법**
  
    - 자원을 추가 요청하기 전, 점유 중인 모든 자원을 일단 해제한다.
  
  
  2. **비선점(No-preemption)조건 방지**
  
    - **원리**
  
      - 프로세스가 점유한 자원을 강제로 해제할 수 있다.
     
    - **방법**
  
      - 어떤 자원을 점유한 프로세스가 추가 자원 요청 시 기다려야 한다면, 프로세스는 현재 점유한 자원을 모두 해제한다.
  
    -**변형된 방법**
  
      - R1을 점유한 P1이 R2를 추가로 요청했을 때, P2가 이미 점유 중이라면 P2의 실행 여부를 검사한다.
  
      - P2가 대기 중이라면, R2를 강탈하여 P1에게 할당할 수 있다.
  
      - P2가 실행 중이라면, P1이 대기해야 한다.
  
      - 프로세스에 우선순위를 부여하여, 높은 우선순위의 프로세스가 낮은 순위의 프로세스가 점유한 자원을 뺏을 수 있도록 한다.
  
      **자원 해제가 필요한 상황이 빈번하지 않은 상황에 이용 가능한 방법
  
  
  3. 순환대기(Cirucular wait) 조건 방지
  
  - **원리**
    - 특정 순서대로만 자원을 요청하게 함으로써, 자원 할당 그래프에 사이클이 형성되지 않게 한다.
  
  - **방법**
    - 모든 자원에 일련의 순서(번호)를 부여하고, 각 프로세스는 이 번호 오름차순으로만 자원을 요청할 수 
  
  
  * * * 
  <h1> 기아 상태 </h1>
  - 프로세스가 작업을 수행하지 못하고 무한히 기다리는 상태
  - 현실적으로 수행할 수 없는 작업이지만, 무기한 연기로 인해 수행할 수 없는 상태에 빠지는 것
  - 프로세스 우선순위에 따라 자원을 할당한 경우, 우선순위가 낮은 프로세스들은 기아 상태에 빠질 수 있음
  
  
  <h2> 기아상태 해결 방안 </h2>
  
  - 기아 상태를 해결하기 위한 방안으로 에이징(aging)이 있음
    - 어떤 자원을 오래 대기할 수록 해당 프로세스의 우선순위를 높여주는 방법
  
  - 프로세스의 우선순위를 수시로 변경해서, 각 프로레스가 높은 우선순위를 가질 기회를 주기
  
  - 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청 큐 사용
  
  
  
  
  
  
  
