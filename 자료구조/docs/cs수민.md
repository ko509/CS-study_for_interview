# Heap, Priority Queue에 대해서 설명해주세요.

우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조

 → 데이터를 우선순위에 따라 처리하고 싶을 때 사용
 
 
실제로 구현하는 것

### 1. 리스트
단순히 리스트를 이용하여 구현 

삽입: O(1) 뒤에 넣으면 돼서

삭제: O(N) 선형탐색

→ 시간 오래걸리기 때문에 우선순위 큐를 만들 때 힙 자료구조 사용 

### 2. 힙 자료구조
완전 이진트리 자료구조의 일종


반 정렬상태 유지


항상 루트 노드를 제거합니다.

새로운 데이터가 삽입되면 상위 노드에서 우선순위를 파악해 부모 자식간의 데이터 중에 우선순위가 가장 높은 데이터가 부모로 올라오도록 한다

만약 삭제가 일어나면 root가 삭제된다 (PQ는 우선순위가 가장 높은 데이터부터 out)그러면 마지막 노드를 root로 올린다음 규칙에 맞게 제자리를 찾도록 노드간의 데이터 교환을 진행한다
    
 ### 1. 최소힙
   부모 노드는 자식 노드보다 작지 않음
   <br>
 ### 2. 최대힙 
   부모 노드는 자식 노드보다 크지 않음
    
  즉, 우선순위가 큰 값인지, 작은값인지에 따라 max or min이 정해진다.
  
  
  우선순위가 가장 높은 데이터가 pop됨!!!!
  
  
  둘 다 완전 이진트리 여야함

  
힙으로 구현된 이진 트리는 모든 정점이 자신의 자식 요소보다 우선순위가 높다는 성질을 가지고 있다. 이 성질을 통해 삽입과 삭제 연산을 모두 O(logN)으로 수행할 수 있다.



정렬된 애들이 삭제되는게 O(1)인 이유는 내가 기준잡아서 정렬했기때문에 바로 빼면 되니깐!


### 시간복잡도

![자료구조](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/86a08a5b-fd65-434a-895d-8e230f1b9e52/Untitled.png)
    

<br>
<br>

# BST의 최악의 경우의 예와 시간복잡도에 대해서 설명해주세요.

Binary Search Tree는  특정 노드의 왼쪽 서브트리 노드들의 값은 항상 작아야하고 오른쪽 서브트리 노드들의 값은 항상 크게 배치되는 트리


즉, 어떤 값을 찾을 때 탐색하는 노드 대상으로 값을 비교한 뒤 
크면 오른쪽만, 작으면 왼쪽만 탐색

<strong> 이진트리의 균형이 적절하다면 탐색 과정의 시간복잡도는 일반적인 경우 O(log N) 저장이나 탐색이 가능 </strong>


하지만 한쪽으로 치우쳐진 트리 즉, 사향 이진트리가 될 경우 최대 O(n)의 시간이 소요!!!
<br>
예를 들어 BST에 1~100을 차례대로 넣으면 1은 2보다 작으니깐 1의 오른쪽에 붙고, 2는 또 3보다 작으니깐 2의 오른쪽에 3이 붙이는 것처럼 
이렇게 한쪽으로 치우친 사향 이진트리가 만들어집니다.

<br>
사향 이진트리는 많은 공간이 낭비될 수 있을 뿐만 아니라 배열 크기 이상 노드를 추가할 수 없습니다.

**정렬된 데이터를 받는 경우!  최악의 시간복잡도**

**→ why? 정렬되어있으면 점점 커지거나 점점 작아지는것**

**점점커지면 오른쪽 점점 작아지는 데이터 왼쪽에 붙어서**
